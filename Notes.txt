(PART-1)
set up reactjs and tailwind and create github repo

-> use command -> npm create vite@latest client 
-> Framework -> react 
-> variant: Â» JavaScript + SWC
-> client is the name of the folder

-> To move from main folder[MERN_REAL_ESTATE] to client -> cd client 
-> INSTALL node -> npm install 

->Than install Tailwind CSS from -> https://tailwindcss.com/docs/guides/vite 
-> Install this extension -> ES7+ React/Redux/React-Native snippets , Auto Rename Tag , 
console-ninja , GitHub Copilot , GitHub Copilot Chat , Prettier - Code formatter, Tailwind CSS IntelliSense 

-> Uploading to Github -> using git and command 



(PART-2) 
-> Its about creating routes in React 
create pages and routes
inside src folder create pages folder
inside pages folder create pages about.jsx,Home.jsx,Signin.jsx,SignOut.jsx

install react router dom in client folder for client side routing
inside browser router specify routes and route and path and element for client side routing

update to git using vs code without commands



(PART-3)
create header Component which is common for all pages
src -> create folder -> components -> Header.jsx -> Header appears in all the pages than created in Part-2
-> in header.jsx -> change tag to meaningfull name for seo purposes 
-> than applying some css to Urban Estate name and Using FlexWrap 
-> install npm i react-icon in client folder to add icon 
-> adding responsiveness using tailwind css like first mobile version than desktop version css
useNavigate() hook from react router dom is used for navigating to different pages


-- 
Now work on backend part of project and create sign in and sign out part of the pages and create api of routes 
and intereact between client and backend

(PART-4)
create and run the server
create folder api in mern real estate
go to folder mern real estate and create package.json using npm init -y 
npm install express in mern estate using npm install express
->To run index.js use -> node api/index.js , be in mern real estate folder only and open from api index.js file 
->Also, install -> npm i nodemon -> to help not to again start server -> any changes automatically reflected


(PART-5) 
-> connect to database our server and using mongoose package to connect to our database
connect to db
npm install mongoose in mern-estate
npm install dotenv in mern-estate
create .env file in mern-estate and add MONGO variable assigned to the connection string
import the dotenv module in index.js
dotenv.config()
add .env file to .gitignore before commit this won't push .env file to github 
->connecting to db little bit complex see accordingly -> add ip address 0.0.0.0/0 

(PART-6) -> Create User Model 
->create first model for our database users which set some rules and conditions that can be added to our database
-> Inside api folder -> create models -> than create schema here 

(PART-7) -> Create a test API route
-> Creating first api routes which is test api route 
-> open api folder -> index.js -> create route 
-> api folder -> create routes folder and controllers folder 
-> created the route and tested its working -> using http://localhost:3000/api/user/test

(PART-8)
->creating SIGNUP api route
->so that user can signup on our application
-> get information like username,mail,password from client side 
-> hash the password and save inside the database 
-> routes created inside route folder but function written inside controllers folder
-> download insomnia api 
-> we don't want to save our password in database directly because if someone hacks database they get access to password or admin has access of password
-> therefore hash it or encrypt for that in mern real estate folder download this package npm i bcryptjs
-> controllers folders -> inside it 2 3 files 

(PART-9) 
->Creating a Middlewares and a function to handle possible erros 
-> middlewares takes care of the errors 
-> create inside api folders -> utils folder -> throw error like password not long enough -> this are custom error created by us -> function name is errorHandler inside utils->error.js

(PART-10) 
->Creating UI of SIGN-UP PAGE 
->inside client->src->pages->signup.jsx go there and create signup page UIs (styling)

(PART-11) -> Complete Sign up page functionality 
->Adding functionality to signup page using Onchange event listener and when submitting details like username , password and mail add it to database
-> use onSubmit={handleSubmit} event listener in form tag 
-> creating proxy of server -> go to vite.config.js and do it -> '/api' -> 'http://localhost:3000' -> whenever seeing /api replace by localhost3000 one
-> handling different error and adding users to database 
-> useNavigate to navigate from sign-up page to signin page when user created successfully [when they click on sign-up button] and added to database


(PART-12) 
-> Creating sign in api route
-> sign in the users and authenticate them
-> first go to routes folder -> auth route file -> create sign in route
-> authenticating user here with there mail and password -> go to controller folder -> auth.controller.js -> here authenticating
->if both mail password correct authenticate the user -> using add cookie inside a browser -> install json webtoken inside mern real estate folder -> using npm i jsonwebtoken 
-> add signin route to route folder -> insider auth.route.js 

CODE -> controller folder -> auth.controller.js


export const signin = async (req,res,next)=>{
 //get data from req.body mails and password 
 const {email , password} = req.body;

 try{
    //check if email exist than only check password 
    const validUser = await User.findOne({email}) ; 
    if(!validUser) return next(errorHandler(404,'User not found!'));
    //else mail exist now see password -> compare user password written with password coming from db
    const validPassword = bcryptjs.compareSync(password, validUser.password);
    if (!validPassword) return next(errorHandler(401, 'Wrong credentials!'));

    //now,if both mail password correct authenticate the user -> using add cookie inside a browser 
    //for all user inside db unique id assign using that for creating token and authenticating user
    const token = jwt.sign({ id: validUser._id }, process.env.JWT_SECRET);

    //we don't want to see password of the user even hashed one -> destructure the password i.e remove from rest information 
    //now no woory of password leak problem
    const { password: pass, ...rest } = validUser._doc;

      //now,save the token as cookies 
    res
      .cookie('access_token', token, { httpOnly: true }) //httpOnly:true makes sure no 3rd party has cookie access
      .status(200)
      .json(rest);
 }catch(error){
    next(error);
 }

};


(PART-13) 
->complete sign in page functionality 
->work on ui and connect it to database 
-> have interactivity between frontend and the backend 
-> remember I have used Signin.jsx file name not SignIn.jsx 
->same as PART-12 
->here, after signin navigate to home page 
->if trying to signin with wrong mail -> user not found! message comes 
->if trying to signin with wrong password -> wrong credentials! message comes 

(PART-14) 
->Adding Redux ToolKit 
-> Using Redux toolkit we will have global state instead of local state
->instead of passing data in different components and pages we will store the data using redux toolkit like -> header info  , profile info etc 
-> allows to access user data in different places than 
-> download rules from https://redux-toolkit.js.org/tutorials/quick-start 
-> download redux dev tools and see action & states accordingly than -> like sign in start , success & failure and test sign in page

(PART-15)
-> if refreshing signin page -> we loose data -> user need to signin again -> problem 
->Add Redux Persist ->to fix this problem and store data in local storage of browsers
->adding user data in local storage using redux persist -> download inside client folder using -> npm i redux-persist
-> user added now in signin page -> refresh the page -> user details still there with persist help -> i.e uses local storage for this purposes 
-> to check open sign in page -> right click -> inspect -> go to redux and see in state
->go to application -> local storage -> current user information stored there 

(PART-16)
-> Add Google OAuth Functionality 
-> inside sign up page -> continue with google option there 
-> src folder -> components folder -> create OAuth.jsx 
-> Add OAuth to Signin and Signup pages 
-> we added continue with google inside form so if clicking on this button it submits signin/signup page to prevent -> inside OAuth.jsx add type='button'
->go to firebase() -> create project and set up & install -> npm install firebase inside client folder


-> continue with google -> on clicking a pop up windows come -> make sure to have 2 3 mail account added -> else if only 1 added pop up not shown 
-> I added 3 account 
-> when continue with google -> using account to continue -> it displayls in console many thing -> we need 3 crucial Information 
-> 1. display name , 2. email , 3. photo url of mail -> than send this data to backend to create this user 
-> In OAuth.jsx basically frontend of the google OAuth functionality is created -> now create backend ->go to api folder-> go to routes folder 
-> go to auth.route.js -> create function insider controllers folder -> inside auth.controllers.js
-> after continue with google -> we redirect to home page 

export const google = async (req, res, next) => {
   try {
      //check if user existed or not -> if not create user -> else signin the user
     const user = await User.findOne({ email: req.body.email });
     //user exixts and authenticating them and signing them
     if (user) {
       const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET);
       const { password: pass, ...rest } = user._doc;
       res
         .cookie('access_token', token, { httpOnly: true })
         .status(200)
         .json(rest); //sending back the user data 
     } else { 
      //create the user , in models -> user.model.js -> requires password: true -> create your own password
       const generatedPassword =
         Math.random().toString(36).slice(-8) +
         Math.random().toString(36).slice(-8);
       const hashedPassword = bcryptjs.hashSync(generatedPassword, 10);
       const newUser = new User({
         username:
           req.body.name.split(' ').join('').toLowerCase() +
           Math.random().toString(36).slice(-4),
         email: req.body.email,
         password: hashedPassword,
         avatar: req.body.photo,
       });
       await newUser.save();
       const token = jwt.sign({ id: newUser._id }, process.env.JWT_SECRET);
       const { password: pass, ...rest } = newUser._doc;
       res
         .cookie('access_token', token, { httpOnly: true })
         .status(200)
         .json(rest);
     }
   } catch (error) {
     next(error);
   }
 };


(PART-17) - update the header and make the profile page private 
-> updating the header section and showing the user who sign in there avatar and once we click on avatar showing user profile page 
-> making user profile page private i.e if person not signin they are not allowed to see profile page 
-> go to src -> components folder -> Headers.jsx -> show signin if user not authenticated and show avatar of user if authenticated 
-> if in sign-in page and user signout and we try to again go to user profile page we are directed to sign-in page again 
-> i.e profile page is authenticated 


(PART-18)
->Complete Profile Page UI 
->insider src -> pages -> profile.jsx -> created the UI -> http://localhost:5173/profile
-> LIKE Title, profile image and a form (for username,mail,password) 

(PART-19) 
->complete image upload functionality
-> change user image -> and add to firebase storage -> so that our file is stored there 
-> go to profile.jsx -> use input type as "file" and add a reference to image 
-> when clicking on profile picture we will accept only image. 
-> creating firebase storage and do the set up 
-> useEffect hook used 
-> uploading image percentage sie like 5 10 20 30 ... 100 
->handleFileUpload()-> takes snapshot of image and upload it , handles error , download url of avatar 
-> tell the user whether image uploaded successfully if 100% or any kind of error found like not a image file or image > 2mb 
-> if everything works fine on clicking profile we can update avatar and new photo shown 


(PART-20) 
->Create update user API route
-> in backend -> to update user there 
-> go to api -> routes -> user.routes.js -> create update route 
-> extra checking in updating -> like check if person is authenticated or not 
-> i.e when we sign in the user we created token inside the cookie use that token to verify the users 
-> if updating wrong user or not authenticated -> give error  
-> inside utils folder -> create verifyUser.js -> install npm i cookie-parser inside mern real estate folder -> for cookies purpose 
-> now verify using token in verifyUser.js user 
-> go to controller -> go to userController.js -> write logic of updating && routes -> userRoute.js -> create update && verify route
-> set method is used to check if data is being changed like user updated mail but not username so on else ignore the data 
-> open insomnia -> send post request and see working of update route like -> localhost:3000/api/user/update/663f061957dad12d4dfd8190 
-> where last no. 663f...90 is id of user who signin and it is being updated , this id is always unique 

if error this message comes from insomnia 

	"success": false,
	"statusCode": 401,
	"message": "You can only update your own account!"
}


(PART-21)
->Complete Update User Functionality
->Connect frontend with backend 
->Add event listener for profile page forms 
->and than connect to api 
-> onchange(for mail & username update) and onsubmit(in form) event listener used 
-> also go to redux folder -> userSlice.js -> add 3 more reducers for update user 
-> here redux toolkit concept used 
-> user updated successfully if no problem occurs else showing unauthorized error -> first continue with google and do the update to your account 

